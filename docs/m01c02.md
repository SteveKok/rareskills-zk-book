# m01 c02 - Arithmetic Circuits for ZK

## Reference

https://rareskills.io/post/arithmetic-circuit

## Notes

-   Circuit can also be written as a collections of arithmetic rules with equal sign.
-   signals - roughly equals to input parameters in normal programming

---

## Practice Problem 1

```ts
// if at least one signal is 0, this circuit will be true
(x_1)(x_2)(x_3)...(x_n) === 0
```

---

## Practice Problem 2

```ts
// Make sure all x_1, x_2, x_3 ... x_n are either 1 or 0
x_1(x_1 - 1) === 0
x_2(x_2 - 1) === 0
x_3(x_3 - 1) === 0
...
x_n(x_n - 1) === 0

// The product will be one only if all of the signals are 1
(x_1)(x_2)(x_3)...(x_n) === 1
```

---

## Practice Problem 3

```ts
// Let's assume that A, B, C ... N represents the color of the nodes of the map
// Their color must be either 1, or 2, where 1 means first colour, and 2 means second colour
(A-1)(A-2) === 0
(B-1)(B-2) === 0
(C-1)(C-2) === 0
...
(D-1)(D-2) === 0

// For every boundary where 2 map nodes connected, if the first node is colour 1, then the second node must be colour 2
// Vice versa, if first node is colour 2, then the second node must be colour 1
// Thus, their product must be 2
AB === 2
// Repeat for every shared boundaries
```

---

## Practice Problem 4

```ts
// Let's assume that x, y, z and k, are greather than 0 but smaller than 7.
// We can add more binaries if the number is greater
x === 4 * x_3 + 2 * x_2 + 1 * x_1;
y === 4 * y_3 + 2 * y_2 + 1 * y_1;
z === 4 * z_3 + 2 * z_2 + 1 * z_1;
k === 4 * k_3 + 2 * k_2 + 1 * k_1;

// each of those binary digit can only be 0 or 1
x_3(x_3 - 1) === 0;
x_2(x_2 - 1) === 0;
x_1(x_1 - 1) === 0;
// repeat for y3, y2, y1, z3, z2, z1, k3, k2, k1

// Since x, y, z, k are numbers from 0 ~ 7, the minimum and maximum result of one number subtract the another is -7 ~ +7
// If this number was added to 8, it will become 1 ~ 15, which will be fit into a 4 digit binary
8 + x - y === 8 * xy_4 + 4 * xy_3 + 2 * xy_2 + 1 * xy_1;
8 + x - z === 8 * xz_4 + 4 * xz_3 + 2 * xz_2 + 1 * xz_1;
8 + y - x === 8 * yx_4 + 4 * yx_3 + 2 * yx_2 + 1 * yx_1;
8 + y - z === 8 * yz_4 + 4 * yz_3 + 2 * yz_2 + 1 * yz_1;
8 + z - x === 8 * zx_4 + 4 * zx_3 + 2 * zx_2 + 1 * zx_1;
8 + z - y === 8 * zy_4 + 4 * zy_3 + 2 * zy_2 + 1 * zy_1;

// each of those binary digit can only be 0 or 1
xy_4(xy_4 - 1) === 0;
// repeat for all others

// If x is the maximum number, then: x - y will be non-negative, x - z will be non-negative too
// 8 adding a non negative number will guaranteed to have its MSB as 1
// So, if xy_4 === 1 and xz_4 === 1, k === x
// But, if any of xy_4 or xz_4 is not 1, then k can be anything
// When 1k === 1x, k must be equal to x
// When 0k === 0x, k can be anything and the circuit still pass
xy_4 * xz_4 * k === xy_4 * xz_4 * x;
yx_4 * yz_4 * k === yx_4 * yz_4 * y;
zx_4 * zy_4 * k === zx_4 * zy_4 * z;

// In the event if there is tie between x, y, z, for the highest, the circuits still valid because k will be equal to both the highest number in that scenario.
```

---

## Practice Problem 5

```ts
// Binary Constraints
x_1(x_1 - 1) === 0;
x_2(x_2 - 1) === 0;
...
x_n(x_n - 1) === 0;

// If any of the signals is 1, then the whole product will immediately become 0
(x_1 - 1)(x_2 - 1)...(x_n - 1) === 0;
```

---

## Practice Problem 6

```ts
// Split v into binaries number
v === 2 ^ (n - 1) * x_n + ... + 4 * x_3 + 2 * x_2 + 1 * x_1;

// Binary Constraints
x_n(x_n - 1) === 0;
...
x_3(x_3 - 1) === 0;
x_2(x_2 - 1) === 0;
x_1(x_1 - 1) === 0;

// For power of two, all binary digits added together must only be 1
x_1 + x_2 + x_3 + ... x_n === 1
```

---

## Practice Problem 7

```ts
// Let's assume the set contains { s_1, s_2, ... s_n }
// Let X = the subset that user submitted
// let x_1 = whether or not s_1 exist in subset X
x_1 * s_1 + x_2 * s_2 + ... x_n * s_n === k

// Binary Constraints
x_1(x_1 - 1) === 0
x_2(x_2 - 1) === 0
...
x_n(x_n - 1) === 0
```

---

## Practice Problem 8

```ts
// Let's assume the set contains { s_1, s_2, ... s_n }
// Let's assume the user submited subset A, B, ...
// Let a_1 = whether or not s_1 exists in subset A
// let b_2 = whether or not s_2 exists in subset B
// Let maximum possible value of k as 7... can increase binary bit size if needed
k === 4 * k_3 + 2 * k_2 + 1 * k_1;
k_3(k_3 - 1) === 0
k_2(k_2 - 1) === 0
k_1(k_1 - 1) === 0

// if any of the a_1, b_1, ... is 1, then diff_1_4, the MSB, will be 0
8 - a_1 - b_1 - ... = 8 * diff_1_4 + 4 * diff_1_3 + 2 * diff_1_2 + 1 * diff_1_1;
diff_1_4(diff_1_4 - 1) === 0
diff_1_3(diff_1_3 - 1) === 0
diff_1_2(diff_1_2 - 1) === 0
diff_1_1(diff_1_1 - 1) === 0
// repeat for s_2, s_3, ... until s_n

// The union of all subsets is the original S, if all diff_1_4, diff_2_4 ... diff_n_4 is 0
(1 - diff_1_4)(1 - diff_2_4)...(1 - diff_n_4) === 1
```
